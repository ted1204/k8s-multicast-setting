#!/bin/bash
set -u
set -e

# ================= Configuration =================
MULTUS_VERSION="v4.0.2"
WHEREABOUTS_VERSION="v0.6.3"
MULTUS_MEM_LIMIT="512Mi"
CNI_CONF_DIR="/etc/cni/net.d"
NAD_NAME=${NAD_NAME:-macvlan-conf}
NAD_NAMESPACE=${NAD_NAMESPACE:-default}
# Default manifest path in repo (more portable)
MANIFEST_PATH=${MANIFEST_PATH:-"../manifests/cni/${NAD_NAME}.yaml"}

# ================= 0. Pre-flight Checks =================
echo "[INFO] Starting pre-flight checks..."

if [ "$EUID" -ne 0 ]; then 
  echo "[ERROR] Please run as root."
  exit 1
fi

if ! kubectl get nodes > /dev/null 2>&1; then
    echo "[ERROR] kubectl cannot connect to the cluster."
    exit 1
fi

# ================= 1. Cleanup Previous Installation =================
echo "[INFO] Cleaning up previous configurations to ensure a fresh install..."

# 1. Delete the NetworkAttachmentDefinition
kubectl delete -f "$MANIFEST_PATH" 2>/dev/null || echo "   - NAD not found (clean)"

# 2. Delete DaemonSets
kubectl delete daemonset -n kube-system whereabouts 2>/dev/null || echo "   - Whereabouts DS not found (clean)"
kubectl delete daemonset -n kube-system kube-multus-ds 2>/dev/null || echo "   - Multus DS not found (clean)"

# 3. Delete CRDs (To fix the broken state)
echo "[INFO] Refreshing CRDs..."
kubectl delete crd ippools.whereabouts.cni.cncf.io 2>/dev/null || true
kubectl delete crd overlappingrangeipreservations.whereabouts.cni.cncf.io 2>/dev/null || true
# Note: We usually don't delete network-attachment-definitions CRD as it might affect other CNI plugins, 
# but we will ensure it is re-applied later.

# 4. Cleanup CNI configs generated by Multus (Optional but recommended for hard reset)
rm -f /etc/cni/net.d/00-multus.conf
echo "[INFO] Cleanup complete. Waiting 10s for API stability..."
sleep 10

# ================= 2. Auto-Detection Logic =================
echo "[INFO] Detecting network configuration..."

DEFAULT_ROUTE=$(ip route show default | head -n1)
DETECTED_IF=$(echo "$DEFAULT_ROUTE" | awk '{for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}')
DETECTED_GW=$(echo "$DEFAULT_ROUTE" | awk '{for(i=1;i<=NF;i++) if($i=="via") print $(i+1)}')

if [ -z "$DETECTED_IF" ] || [ -z "$DETECTED_GW" ]; then
    echo "[ERROR] Could not detect interface/gateway. Set MASTER_IF and GATEWAY manually."
    exit 1
fi

DETECTED_CIDR=$(ip -o -f inet addr show "$DETECTED_IF" | awk '{print $4}' | head -n1)

if [ -z "${RANGE:-}" ]; then
    IP_PREFIX=$(echo "$DETECTED_GW" | cut -d. -f1-3)
    DETECTED_RANGE="${IP_PREFIX}.200-${IP_PREFIX}.250/24"
    echo "[WARN] using auto-detected range: $DETECTED_RANGE"
else
    DETECTED_RANGE=$RANGE
fi

MASTER_IF=${MASTER_IF:-$DETECTED_IF}
GATEWAY=${GATEWAY:-$DETECTED_GW}
RANGE=$DETECTED_RANGE

echo "-------------------------------------------------------"
echo "Active Configuration:"
echo "  Interface : $MASTER_IF"
echo "  Gateway   : $GATEWAY"
echo "  IP Range  : $RANGE"
echo "-------------------------------------------------------"

# Try to detect cluster Pod CIDR to validate no-overlap between Pod network and macvlan range.
# Can be overridden by setting POD_CIDR env var.
if [ -z "${POD_CIDR:-}" ]; then
  POD_CIDR=$(kubectl get nodes -o jsonpath='{.items[0].spec.podCIDR}' 2>/dev/null || true)
fi

echo "Detected POD_CIDR: ${POD_CIDR:-<none>}"

# Validate that macvlan RANGE does not overlap POD_CIDR and that gateway/host IP not inside RANGE
python3 - <<PY || { echo "[ERROR] Network validation failed (overlap or gateway in range). Aborting."; exit 1; }
import ipaddress,sys,re
try:
  # parse POD_CIDR
  pod = ipaddress.ip_network('${POD_CIDR}') if '${POD_CIDR}' else None
  # parse macvlan range (format: 192.168.109.200-192.168.109.250/24)
  s='${RANGE}'
  # handle formats like '192.168.109.200-192.168.109.250/24' or plain CIDR
  m=re.match(r'(.+)-(.+)/([0-9]+)', s)
  range_start = range_end = None
  if not m:
    # try CIDR only
    mac_net=ipaddress.ip_network(s)
    range_start = mac_net.network_address
    range_end = mac_net.broadcast_address
  else:
    start, end, cidr = m.group(1).strip(), m.group(2).strip(), m.group(3).strip()
    # derive network from start with given mask
    mac_net=ipaddress.ip_network(start + '/' + cidr, strict=False)
    range_start = ipaddress.ip_address(start)
    range_end = ipaddress.ip_address(end)

  gw=ipaddress.ip_address('${GATEWAY}') if '${GATEWAY}' else None
  # host IP on MASTER_IF
  import subprocess,json
  try:
    out=subprocess.check_output(['ip','-4','-o','addr','show', '${MASTER_IF}']).decode()
    host_ip=out.split()[3].split('/')[0]
    host_ip=ipaddress.ip_address(host_ip)
  except Exception:
    host_ip=None

  if pod and mac_net and pod.overlaps(mac_net):
    print('ERROR: POD_CIDR overlaps MACVLAN network:', pod, mac_net)
    sys.exit(2)
  # For gateway/host checks, only consider the explicit allocation range (start-end)
  def in_range(ip, start, end):
    try:
      return start <= ip <= end
    except Exception:
      return False

  if gw and range_start and range_end and in_range(gw, range_start, range_end):
    print('ERROR: GATEWAY is inside MACVLAN allocation range:', gw)
    sys.exit(2)
  if host_ip and range_start and range_end and in_range(host_ip, range_start, range_end):
    print('ERROR: Host interface IP is inside MACVLAN allocation range:', host_ip)
    sys.exit(2)
except Exception as e:
  print('Validation exception:', e)
  sys.exit(2)
PY

echo "Network validation passed: POD_CIDR vs MACVLAN range OK"
# ================= 3. Install Multus =================

echo "[INFO] Installing Multus CNI (Thick Plugin)..."
MULTUS_URL="https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/${MULTUS_VERSION}/deployments/multus-daemonset-thick.yml"

curl -sL "$MULTUS_URL" | sed "s/memory: .*/memory: $MULTUS_MEM_LIMIT/g" | kubectl apply -f -

echo "[INFO] Patching Multus DaemonSet for /opt/cni/bin visibility..."
kubectl patch daemonset kube-multus-ds -n kube-system --type='json' -p='[
  {"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "cni-bin", "hostPath": {"path": "/opt/cni/bin", "type": "Directory"}}},
  {"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts/-", "value": {"name": "cni-bin", "mountPath": "/opt/cni/bin"}}
]' || echo "[INFO] Patch might have already been applied."

echo "[INFO] Waiting for Multus rollout..."
kubectl -n kube-system rollout restart daemonset/kube-multus-ds
kubectl -n kube-system rollout status daemonset/kube-multus-ds --timeout=300s

# Apply RBAC needed by Multus/Whereabouts to read pods/nodes (fix permission issues)
RBAC_MANIFEST_PATH="$(dirname "$MANIFEST_PATH")/multus-whereabouts-rbac.yaml"
if [ -f "$RBAC_MANIFEST_PATH" ]; then
  echo "[INFO] Applying Multus/Whereabouts RBAC: $RBAC_MANIFEST_PATH"
  kubectl apply -f "$RBAC_MANIFEST_PATH" || true
fi

# ================= 4. Install Whereabouts (FIXED) =================

echo "[INFO] Installing Whereabouts IPAM and CRDs..."
BASE_URL="https://raw.githubusercontent.com/k8snetworkplumbingwg/whereabouts/${WHEREABOUTS_VERSION}/doc/crds"

# 1. Install the DaemonSet
kubectl apply -f "${BASE_URL}/daemonset-install.yaml"

# 2. FIX: Install IPPools CRD
kubectl apply -f "${BASE_URL}/whereabouts.cni.cncf.io_ippools.yaml"

# 3. CRITICAL FIX: Patch OverlappingRangeIPReservation CRD
# The default CRD requires 'containerid', but the CNI plugin sometimes doesn't send it.
# We download, patch (remove the requirement), and then apply.
echo "[INFO] Patching OverlappingRange CRD to remove 'containerid' requirement..."
curl -sL "${BASE_URL}/whereabouts.cni.cncf.io_overlappingrangeipreservations.yaml" -o /tmp/crd-overlapping.yaml

# 使用 sed 刪除含有 "- containerid" 的那一行 (支援任意空白)
sed -i '/^\s*-\s*containerid/d' /tmp/crd-overlapping.yaml

kubectl apply -f /tmp/crd-overlapping.yaml
rm -f /tmp/crd-overlapping.yaml

echo "[INFO] Waiting for Whereabouts rollout..."
sleep 5
kubectl -n kube-system rollout status daemonset/whereabouts --timeout=300s

# Ensure RBAC applied takes effect: restart multus/whereabouts pods so they retry with new permissions
kubectl -n kube-system rollout restart daemonset/kube-multus-ds || true
kubectl -n kube-system rollout restart daemonset/whereabouts || true
kubectl -n kube-system rollout status daemonset/kube-multus-ds --timeout=120s || true
kubectl -n kube-system rollout status daemonset/whereabouts --timeout=120s || true
# ================= 5. Configure Macvlan NAD =================

echo "[INFO] Configuring Macvlan NetworkAttachmentDefinition..."
cat <<EOF > "$MANIFEST_PATH"
apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: $NAD_NAME
  namespace: $NAD_NAMESPACE
spec:
  config: '{
      "cniVersion": "0.3.1",
      "type": "macvlan",
      "master": "$MASTER_IF",
      "mode": "bridge",
      "mtu": 1500,
      "ipam": {
        "type": "whereabouts",
        "range": "$RANGE",
        "gateway": "$GATEWAY",
        "routes": [ { "dst": "0.0.0.0/0" } ]
      }
    }'
EOF
kubectl apply -f "$MANIFEST_PATH"

# ================= 6. Verification =================
echo "[INFO] Verifying Installation..."

# Check Multus
MULTUS_PODS=$(kubectl get pods -n kube-system -l app=multus --field-selector=status.phase!=Running --no-headers 2>/dev/null | wc -l)
if [ "$MULTUS_PODS" -ne 0 ]; then
   echo "[ERROR] Some Multus pods are not running."
   exit 1
fi

# Check ippools CRD (Critical Check)
if ! kubectl get crd ippools.whereabouts.cni.cncf.io >/dev/null 2>&1; then
    echo "[ERROR] CRD 'ippools' not found. Whereabouts installation failed."
    exit 1
fi

echo "-------------------------------------------------------"
echo "[SUCCESS] Network Setup Complete."
echo "Range: $RANGE"
echo "CRDs for Whereabouts verified."
echo "-------------------------------------------------------"